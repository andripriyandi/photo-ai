# Photo AI – Test Project

A small **single-screen Flutter app** that turns a user’s portrait into multiple AI-generated “remix” scenes.

This project implements the technical brief:

- Flutter app with **one main screen**
- **Firebase Anonymous Auth**
- **Firebase Storage** for original + generated images
- **Cloud Firestore** for metadata
- **Firebase Cloud Functions (TypeScript)** to call the **Gemini image generation API** (or NanoBanana-compatible endpoint)
- Original + generated images stored in Firebase and displayed in the app

The UI is designed as a **clean, Apple Design Award–style single screen**: simple hierarchy, modern typography, smooth transitions, and responsive layout.

---

## 1. Tech Stack

### Frontend (Flutter)

- Flutter (Material)
- `firebase_core`
- `firebase_auth`
- `cloud_firestore`
- `firebase_storage`
- `cloud_functions`
- `image_picker`

### Backend (Firebase)

- Firebase Authentication (Anonymous)
- Cloud Firestore
- Cloud Storage
- Cloud Functions (Node 20, **TypeScript**)
- Google Gemini image generation API (via HTTPS call inside the Function)

---

## 2. High-Level Flow

1. App starts → user is automatically signed in **anonymously**.
2. User drops/selects a portrait on the **single main screen**.
3. The app:
   - Uploads the original image to **Cloud Storage**
   - Calls a callable Cloud Function `generateImages` with the image path and a session id.
4. The Cloud Function:
   - Downloads the original image from Storage
   - Calls the **Gemini image generation API** with several style prompts
   - Stores each generated image back to Storage under the same session
   - Returns the list of generated image paths.
5. The Flutter app:
   - Stores session metadata in Firestore (`users/{uid}/sessions/{sessionId}`)
   - Resolves Storage paths to download URLs
   - Displays the original + generated scenes in a responsive grid.

All AI calls and secrets stay in the **Cloud Function**, not in the client.

---

## 3. Project Structure

```text
photo_ai_test/
├─ lib/
│  ├─ main.dart
│  ├─ firebase_options.dart          # generated by `flutterfire configure`
│  └─ features/
│     ├─ domain/
│     │  ├─ entities/
│     │  │  └─ photo_session.dart
│     │  └─ repositories/
│     │     └─ photo_session_repository.dart
│     ├─ data/
│     │  └─ repositories/
│     │     └─ photo_session_repository_impl.dart
│     └─ presentation/
│        └─ pages/
│           └─ photo_ai_page.dart
├─ functions/
│  ├─ src/
│  │  └─ index.ts                    # Cloud Function: generateImages
│  ├─ lib/                           # compiled JS output
│  ├─ package.json
│  ├─ tsconfig.json
│  └─ .eslintrc.js (optional)
├─ firestore.rules
├─ storage.rules
└─ README.md
```
## 4. Deployment Notes & Limitations

This project is built to use **Firebase Cloud Functions (gen 2, Node 20)** to call the Gemini image generation API.  
As of now, deploying Cloud Functions to Firebase requires the project to be on the **Blaze (pay-as-you-go) plan**. The free Spark plan cannot enable some required APIs (such as `cloudbuild.googleapis.com` and `artifactregistry.googleapis.com`), so deployment from my personal account is intentionally skipped.

For this take-home project:

- The **function code is fully implemented** in `functions/src/index.ts` and compiles successfully with `npm run build`.
- Locally, the function can be run via the **Firebase Emulator Suite**:

  ```bash
  cd functions
  npm run build
  npm run serve